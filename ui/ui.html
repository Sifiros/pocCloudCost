<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.19.1/moment.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.19.1/locale/fr.js"></script>
<script
  src="https://code.jquery.com/jquery-3.2.1.min.js"
  integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
  crossorigin="anonymous"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.1/Chart.min.js"></script>
<script type="text/javascript" src="./savingChart.js"></script>
<script type="text/javascript" src="./horizontalLineChartPlugin.js"></script>
<script type="text/javascript" src="./eventSavings.json"></script>
<style>
    canvas {
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
    }
</style>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<h1>Test</h1>
<div style="width:75%;">
    <canvas id="teevityChart"></canvas>
</div>

<!-- create a table with elems created by caussa -->

<div id="tableContainer">
        <table id="dataTable" class="table table-responsive table-sm table-striped"></table>
</div>

<script>

    window.onload = function() {
            registerPlugin('teevityChart');
            const eventTypes = datas.eventNames
            var datasets = []
            const savings = datas.savings.query({
                groupBy: ['date', 'type'],
                mergeWith: ['saving']
            })
            var savingDatas = eventTypes.reduce(function (result, cur) {
                return Object.assign(result, { [cur]: [] })
            }, {})

            const costs = datas.costs.query({
                groupBy: ['date'],
                mergeWith: ['cost', 'saving']
            })
            var costDatas = Object.keys(costs).map(function (date) {
                // On ajoute les bénéfices pour chaque event & pour la même date
                for (var type of eventTypes) {
                    if (date in savings && type in savings[date]) {
                        savingDatas[type].push(savings[date][type])
                    } else {
                        savingDatas[type].push({
                            date: date,
                            saving: 0
                        })
                    }
                }
                return costs[date]
            })
            datasets.push(metricsToDataset('Total costs', costDatas, 'cost'))
            // console.log('costs = ' + JSON.stringify(costs))
            for (var type in savingDatas) {
                datasets.push(metricsToDataset(type, savingDatas[type]))
            }



            // console.log('#> savings : ' + JSON.stringify(savings))
            // Object.keys(datas.eventSavings).map(function(eventName) {
            //     return metricsToDataset(eventName, datas.eventSavings[eventName])
            // })


            window.chart = new TeevityChart('teevityChart', 'Teevity Savings', datasets)
            window.chart.refresh();

            function metricsToDataset(datasetName, resources, valueKey = 'saving') {
                return ({
                    label: datasetName,
                    data: resources.map(function (cur) {
                        cur.value = cur[valueKey]
                        return cur;
                    }),
                    fill: true
                });
            }

            const tabScopes = datas.eventScopes.query({
                groupBy: ['type', 'CAU']
            })
            var tableHead = "<tr><th>startDate</th>";
            tableHead += "<th>endDate</th>";
            tableHead += "<th>savings</th></tr></thead><tbody>";
            var totalEarned = 0;
            var earnedDuringCurrentEventType;
            var earnedDuringCurrentCAU;
            var finalStr = "";

            for (teevityEventType in tabScopes) {
                earnedDuringCurrentEventType = 0;
                var strToAppend = "";
                for (costAllocationUnit in tabScopes[teevityEventType]) {
                    earnedDuringCurrentCAU = 0;
                    tabScopes[teevityEventType][costAllocationUnit].forEach(function (item) {
                        totalEarned += item.saving;
                        earnedDuringCurrentEventType += item.saving;
                        earnedDuringCurrentCAU += item.saving;
                        strToAppend += "<tr><td>" + moment(item.startDate).format('MMMM Do YYYY, h:mm:ss a') + "</td>";
                        strToAppend += "<td>" + moment(item.endDate).format('MMMM Do YYYY, h:mm:ss a') + "</td>";
                        strToAppend += "<td>" + item.saving + "</td></tr>";
                    });
                    strToAppend = "<tr><th scope='row'>" + "CAU : " + costAllocationUnit + "</th><th></th><th>" +
                    earnedDuringCurrentCAU + "</th></tr>" + strToAppend;
                }
                finalStr += "<tr><th scope='row'>" + "Event type : " + teevityEventType + "</th><th></th><th>" +
                earnedDuringCurrentEventType + "</th></tr>" + strToAppend;
           }
            finalStr = "<thead><tr><td><b>" + "The total amount of Savings in this period is " + totalEarned +
                "</b></td></tr>" + tableHead + finalStr + "</tbody>";

            $('#dataTable').append(finalStr);
    }

    Array.prototype.query = function(opts = {}) {
        var where = opts.where || false
        var mergeWith = opts.mergeWith || false
        var groupBy = opts.groupBy || false
        var tab = this

        if (where) {
            var tab = execWhere(tab, where)
        }
        if (groupBy) {
            var tab = execGroupBy(tab, groupBy)
        } else if (mergeWith) {
            var tab = execMerge(tab, mergeWith)
        }
        return  tab

        function execWhere(tab, where) {
            return tab.filter(function(cur) {
                return Object.keys(where).every(function(key) {
                    return  tab[key] == where[key]
                })
            })
        }
        function execMerge(tab, mergeWith) {
            return tab.slice(1).reduce(function(merge, current) {
                for (key in mergeWith)
                    merge[key] += current[key]
                return merge
            }, tab[0])
        }
        function execGroupBy(tab, groupBy) {
            var groups = {}
            var everyContainers = {}//groupBy.length == 1 ? groups : {}

            for (var row of tab) {
                var curLvl = groups
                var id = ""
                for (var i = 0; i < groupBy.length; i++) {
                    const end = (i == (groupBy.length - 1))
                    var name = row[(groupBy[i])]
                    id += name
                    if (!(name in curLvl)) {
                        curLvl[name] = end ? [] : {}
                    }
                    if (!end) {
                        curLvl = curLvl[name]
                    } else {
                        if (!(id in everyContainers))
                            everyContainers[id] = curLvl
                        curLvl[name].push(row)
                    }
                }
            }

            // Apply merge
            if (mergeWith) {
                for (key in everyContainers) {
                    for (key2 in everyContainers[key]) {
                        if (everyContainers[key][key2] instanceof Array) {
                            // console.log('#> gonna merge ' + key2 + ' = ' + JSON.stringify(everyContainers[key][key2]))
                            everyContainers[key][key2] = execMerge(everyContainers[key][key2], mergeWith)
                        }
                    }
                }
            }
            return groups
        }
    }
</script>
